<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Building Games with Akka FSM</title>

    <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon; charset=binary">

    <meta name="description" content="Building Games with Akka FSM">
    <meta name="author" content="Josep Prat">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/beige.css" id="theme">
    <link rel="stylesheet" href="css/gd.css"/>

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		
		
    <script>
  	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  	ga('create', 'UA-68268154-1', 'auto');
  	ga('send', 'pageview');

     </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div id="gdSlides" class="reveal">
    <div class="badge"></div>

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

        <section>
            <div class="logo"></div>
            <h1 >Building Games with Akka FSM</h1>
            <footer>
                <p class="author">
                    <small>GOTO nights | 2015/10/07 | Josep Prat | GameDuell GmbH | <a href="http://twitter.com/jlprat">@jlprat</a></small>
                </p>
            </footer>
        </section>
        <section>
            <section>
                <h1>Why Games?</h1>
            </section>
            <section>
                <blockquote>"We've been playing games since humanity had civilization - there is something primal about our desire and our ability to play games"<br><span class="author">Jane McGonigal</span></blockquote>
            </section>
            <section id="motto" data-background="images/GD_motto.png" data-background-size="contain" data-transition="linear" data-background-transition="slide">
                <h1>GameDuell</h1>
                <h3>Bringing people together to have good times with games - Wherever, whenever!</h3><br><br><br>
            </section>
            <section>
                <h2>Who are we?</h2>
                <ul>
                    <li>Founded in Berlin back in 2003</li>
                    <li>Over 220 Employees</li>
                    <li>More than 70 Games</li>
                    <li>Over 125 Million Players</li>
                    <li>Tech Talks with World Experts</li>
                </ul>
            </section>
        </section>
        <section>
            <h1>What to expect</h1>
            <ul>
                <li>Converting Games to State Machines</li>
                <li>What is Akka</li>
                <li>Writing FSM with Akka</li>
            </ul>
        </section>
        <section>
            <section>
                <h1>Games</h1>
                <h3 class="fragment">but... what type of games?</h3>
            </section>
            <section>
                <h2>Single Player</h2>
                <img src="images/space_invaders.jpg" alt="http://best-games.fr/wp-content/thumbs/space_invaders1_1343057412.jpg"/>
                <aside class="notes">These games are typically played by one player, and they can be played alone without any other player interaction. The maximum interaction between players is limited to compare scores or time spend without dying.</aside>
            </section>
            <section>
                <h2>Multiplayer</h2>
                <img src="images/bel.png"/>
                <aside class="notes">These games need to be played with other players (better if humans). Players need play at the same time, by turns or not, depending on the game. This games are more social.</aside>
            </section>
            <section>
                <h2>Challenges for Multiplayer Games</h2>
                <ul>
                    <li>Synchronization</li>
                    <li>Data Integrity</li>
                    <li>Resilient</li>
                    <li>Responsive</li>
                </ul>
                <aside class="notes">For a Developer point of view this type of games are more interesting because we need synchronization, to keep data integrity. And ideally, we need to build the games in a resilient and responsive way. Do not mistake it by Responsive Web Design!</aside>
            </section>
            <section>
                <h2>A game is just a FSM behind the scenes</h2>
                <img src="images/simpleStateMachine.svg" alt="Finite-State Machine Sample" class="no-border"/>
            </section>
            <section>
                <h1 class="fragment onTop blink">Not this!!!</h1>
                <img class="below half" src="images/fsm_monster.png" alt="http://img07.deviantart.net/1381/i/2008/268/9/e/the_flying_spaghetti_monster_by_kaddywhak.png"/>
            </section>
            <section>
                <h2>Finite-State Machine</h2>
                <blockquote>
                    <p>
                        Is a mathematical model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of states.
                    </p>
                    <span class="author">Wikipedia</span>
                </blockquote>
            </section>
            <section>
                <h2>How it works</h2>
                <ul>
                    <li>The machine is in only one state at a time</li>
                    <li>It can change from one state to another when initiated by a triggering event or condition</li>
                    <li>It is defined by both a list of its states and the triggering condition for each transition</li>
                    <li>It can have a set of entry and exit actions</li>
                </ul>
            </section>
            <section>
                <h2>Translating Games into FSM</h2>
                <h3 class="fragment">Let's pick a Game</h3>
            </section>
            <section>
                <h2>Battleship</h2>
                <img src="images/battleshipGame.png" alt="Battleship board game"/>
            </section>
            <section>
                <h2>Rules</h2>
                <ul>
                    <li>Every player places their ships in a 10x10 board</li>
                    <li class="fragment">Each ship occupies a number of consecutive squares on the grid, vertically or horizontally</li>
                    <li class="fragment">Each type of ship occupies a determined number of squares</li>
                    <li class="fragment">Each player selects a position to shoot in turns</li>
                    <li class="fragment">Opponent must reveal if a ship was hit or not</li>
                    <li class="fragment">When all squares occupied by a ship are hit, the ship is sunk</li>
                    <li class="fragment">When a player sinks all opponent's ships, the game is over</li>
                </ul>
            </section>
            <section>
                <h2>Building the Finite-State Machine</h2>
                <img src="images/battleship.svg" alt="Battleship game FSM" class="no-border"/>
                <aside class="notes">We start in an idle state. The only way out of this state is start placing ships. This part of the game has no turns, as we don't care who is placing the ships and in which order. Next state, is the one where the machine will stay until both users have placed all ships.
                Now it's when the game properly said starts. Each player in turn is placing a Shot. The shot is evaluated, and it's decided wether it's a hit or a miss.
                In case of hitting an opponent ship, the machine checks if there are still ships alive or not. In the positive case, it's turn for next player to place a shot. Otherwise, the game is finished.</aside>
            </section>
        </section>
        <section>
            <section>
                <h1>What is Akka?</h1>
            </section>
            <section>
                <h2>Akka...</h2>
                <ul>
                    <li>Is an Open-source toolkit and runtime</li>
                    <li>Aims to simplify concurrent and distributed applications</li>
                    <li>Supports multiple programming models</li>
                    <li>Emphasizes the Actor Model, deeply inspired by Erlang's Actor Model</li>
                    <li>Has both Java and Scala APIs</li>
                </ul>
            </section>
            <section>
                <h2>Actors in General</h2>
                <p>Actors are lightweight programmable queues of immutable messages which are processed asynchronously and in a non-concurrent fashion. They can communicate with other actors via immutable messages.</p>
                <p class="fragment">Also known as:<br/><code>Any => Unit</code></p>
                <aside class="notes">They have less footprint than a Thread. They process messages in an asynchronous fashion, and they can share only immutable messages. Their current problem is that they have absolutely no type safety as they are, at the end, a function from Any to Unit. Meaning, from whatever to nothing. Good needs however, a new version of Typed Actors is on the way (still experimental. http://doc.akka.io/docs/akka/2.4.0/scala/typed.html)</aside>
            </section>
            <section>
                <h2>Some Benefits of Using Actors</h2>
                <ul>
                    <li>No need for Locking</li>
                    <li>Message Driven</li>
                    <li>Scalability</li>
                    <li>Better analogies with human behavior</li>
                </ul>
            </section>
            <section>
                <h2>A simple Example (I)</h2>
                <pre><code>sealed trait Message
case object Ping extends Message
case object Pong extends Message
                </code></pre>
                <aside class="notes">We define the messages to be exchanged.</aside>
            </section>
            <section>
                <h2>A simple Example (and II)</h2>
                <pre><code>class PingPongActor extends Actor {

  def ping(times: Int): Receive = {
    case Ping =>
      println(s"Actor Received Ping, transition $times")
      context.become(pong(times + 1))
  }

  def pong(times: Int): Receive = {
    case Pong =>
      println(s"Actor Received Pong, transition $times")
      context.become(ping(times + 1))
  }

  override def receive: Receive = ping(0)
}</code></pre>
                <aside class="notes">The actor it self is just a function called receive that must return the partial function Receive (The famous Any => Unit). But actos can change their behavior on the fly calling context.become. Become takes a Receive as a parameter and changes the actor behavior.
                Here the actor oscillates between waiting for a ping and waiting for a pong behaviors.</aside>
            </section>
            <section>
                <h2>Running It</h2>
                <pre><code>val pingPongActor = system.actorOf(Props[PingPongActor], "PingPongActor")
pingPongActor ! Ping
pingPongActor ! Ping
pingPongActor ! Pong
pingPongActor ! Ping

>Received Ping, transition 0
>Received Pong, transition 1
>Received Ping, transition 2</code></pre>
                <aside class="notes">To send a message to an actor the "bang" operator is used. The actor is sent some Pings and Pongs. Notice that the second Ping in a row is not aknowledged as the Actor doesn't expect it.</aside>
            </section>
            <section>
                <h2>Akka FSM</h2>
                <p>A subtype of Actors that model a Finite-State Machine. It's described as a set of relations of:<br/><code>State(S) x Event(E) -> Actions(A), State(S')</code></p>
                <aside class="notes">These actors are the ones that interest us in today's talk. We gained some type safety, but still not much.</aside>
            </section>
            <section>
                <h2>A simple Example (I)</h2>
                <pre><code>sealed trait Message
case object Ping extends Message
case object Pong extends Message

sealed trait State
case object WaitingPing extends State
case object WaitingPong extends State

case class Data(times: Int)</code></pre>
            </section>
            <section>
                <h2>A simple Example (and II)</h2>
                <pre><code>class PingPongFSM extends Actor with FSM[State, Data] {

  startWith(WaitingPing, stateData = new Data(0))

  when(WaitingPing) {
    case Event(Ping, data:Data) =>
      println(s"Received Ping, transition ${data.times}")
      goto(WaitingPong) using new Data(data.times + 1)
  }

  when(WaitingPong) {
    case Event(Pong, data:Data) =>
      println(s"Received Pong, transition ${data.times}")
      goto(WaitingPing) using new Data(data.times + 1)
  }
  initialize()
}</code></pre>
                <aside class="notes">The actor must extend FSM trait as well that takes two extra types, one for the State another one for the Data stored for the state.
                The definition of this actor is more readable as it uses a high level DSL. Each state is defined within a when partial function.
                In order to move the state machine goto or stay can be used (among others)</aside>
            </section>
            <section>
                <h2>Running It</h2>
                <pre><code>val pingPongFSM = system.actorOf(Props[PingPongFSM], "PingPongFSM")
pingPongFSM ! Ping
pingPongFSM ! Ping
pingPongFSM ! Pong
pingPongFSM ! Ping

>Received Ping, transition 0
>[WARN] ... unhandled event Ping in state WaitingPong
>Received Pong, transition 1
>Received Ping, transition 2</code></pre>
                <aside class="notes">Again the actor is sent some Pings and Pongs. Notice that the second Ping in a row is not aknowledged as the Actor doesn't expect it. Furthermore we get a notification that the actor got a message when in WaitingPong state that was unexpected.</aside>
            </section>
            <section>
                <h2>What about tests?</h2>
                <pre><code>"A PingPongFSM actor" must {
  "behave in Ping Pong fashion" in {
    val pingPongFSM = TestFSMRef(new PingPongFSM)
    assert(pingPongFSM.stateName === WaitingPing)
    pingPongFSM ! Ping
    assert(pingPongFSM.stateName === WaitingPong)
    pingPongFSM ! Ping
    assert(pingPongFSM.stateName === WaitingPong)
    pingPongFSM ! Pong
    assert(pingPongFSM.stateName === WaitingPing)
    pingPongFSM ! Ping
    assert(pingPongFSM.stateName === WaitingPong)
  }
}</code></pre>
                <aside class="notes">This run similarly as the previous run, but we can check the insights of the state machine, for example evaluating in which state it is. We can also change the Data or the State itself.</aside>
            </section>
        </section>
        <section>
            <section>
                <h1>Games to Akka FSM</h1>
                <aside class="notes">Time to convert Game FSM to Akka code</aside>
            </section>
            <section>
                <h2>Remember the Battleship Game?</h2>
                <img src="images/battleship.svg" alt="Battleship game FSM" class="no-border"/>
            </section>
            <section>
                <h2>How many actors?</h2>
                <p class="fragment">It depends...</p>
                <ul class="fragment">
                    <li>How many "units" do exist?</li>
                    <li>Are there too many states?</li>
                    <li>Is some part I/O extensive?</li>
                </ul>
                <aside class="notes">This is the Million $ question. It really depends on each individual case and requirements.
                We can write as many actors as diferent "sub state machines" are contained in the FSM.
                Or when the FSM is too big, we could divide them in blocks and each block would be a different actor.
                Or maybe there are some states (or parts of all states) are I/O extensive, so they are most of the time reading or writing something. Then is better to extract them into a different actor.</aside>
            </section>
            <section>
                <h2>How do we orchestrate all these?</h2>
                <img class="no-border" src="images/battleshipOrchestration.svg" alt="Orchestration of Actors"/>
                <aside class="notes">As an example of the last point, here we have an specific actor only for User I/O. In this case reading from and writing to a WebSocket.
                Then the game logic is concealed in a different actor that delegates the actual user communication to the user to this other actors.</aside>
            </section>
            <section>
                <h1 class="blink">WARNING!</h1>
                <h2>The Following Code has been simplified for clarity</h2>
                <h3>Don't run this code at home!</h3>
                <aside class="notes">In order to have some comprehensive and showable slides, the code listed here is a simplification.</aside>
            </section>
            <section>
                <h2>Let's create the State Objects</h2>
                <pre><code>sealed trait BattleshipState
case object WaitingForPlayers extends BattleshipState
case object PlacingShips extends BattleshipState
case object WaitingForNextPlayer extends BattleshipState
case object CheckingShot extends BattleshipState
case object HitShip extends BattleshipState
case object EndGame extends BattleshipState</code></pre>
            </section>
            <section>
                <h2>Now the Messages Sent</h2>
                <pre><code>sealed trait BattleshipMessages
case class PlaceShip(playerId: Int, id: Short, coord: Coord,
     size: Short, vertical: Boolean) extends BattleshipMessages
case object ShipsPlaced
case object NextPlayer
case class PlaceShot(playerId: Int, coord: Coord)
     extends BattleshipMessages
case object Miss extends BattleshipMessages
case object Hit extends BattleshipMessages
case object ShipsAlive extends BattleshipMessages
case object AllShipsSunk extends BattleshipMessages

case class Message(msg: String)</code></pre>
            </section>
            <section>
                <h2>What do we need as a State Data?</h2>
                <ul>
                    <li class="fragment">Both Grids</li>
                    <li class="fragment">Who is in turn</li>
                    <li class="fragment">Ships to Place</li>
                    <li class="fragment">Shot to Check</li>
                </ul>
                <aside class="notes">This is not a law, every developer can come up with a different version of the Sate class, as it's the most subjective one.</aside>
            </section>
            <section>
                <h2>Let's focus on the first state</h2>
                <img src="images/battleship.svg" alt="Battleship game FSM" class="no-border"/>
            </section>
            <section>
                <h2>Let's focus on the first State</h2>
                <pre><code>class BattleShipActor(player1: ActorRef, player2: ActorRef)
   extends ActorLogging with FSM[BattleshipState, BattleshipData] {
 ...
 when(WaitingForPlayers) {
  case Event(PlaceShip(playerId, shipId, coord, size, vertical), data)=>
    if (data.canShipBePlaced(playerId, shipId, coord, size, vertical))
      sender ! Message("Placed")
    else sender ! Message("Wrong Position")
    goto(PlacingShips) using
      data.placeShip(playerId, shipId, coord, size, vertical)
 }
 ...
}</code></pre>
                <h3 class="fragment">Easy, huh?</h3>
                <aside class="notes">Almost direct translation from the FSM. This state might also contain some initialization code for example</aside>
            </section>
            <section>
                <h2>Let's focus on the second state</h2>
                <img src="images/battleship.svg" alt="Battleship game FSM" class="no-border"/>
            </section>
            <section>
                <h2>Let's focus on the second state</h2>
                <pre><code>when(PlacingShips) {
 case Event(PlaceShip(playerId, shipId, coord, size, vertical), data)=>
   if (data.canShipBePlaced(playerId, shipId, coord, size, vertical))
     if (data.canShipBePlaced(playerId, shipId, coord, size, vertical))
       sender ! Message("Placed")
     else sender ! Message("Wrong Position")
     stay using data.placeShip(playerId, shipId, coord, size, vertical)
   else stay
 case Event(ShipsPlaced, data) =>
   players.foreach(_ ! Message("Ships placed"))
   goto(WaitingForNextPlayer)
}</code></pre>
                <h3 class="fragment">Who sends this Ships Placed message?</h3>
                <aside class="notes">Here we can see that we rely on something sending the event ShipsPlaced. Can we rely on the user sending this? Obviously not, who sends it, it's explained in the next slide</aside>
            </section>
            <section>
                <h2>We must define our Entry Actions!</h2>
                <pre><code>onTransition {
 case _ -> PlacingShips =>
   if (nextStateData.shipsToPlace.forall(_.isEmpty)) self ! ShipsPlaced
}</code></pre>
                <aside class="notes">Entry actions are a set of actions that will be executed when transitioning from one state to another.
                    In this case, no matter from which state we come, as soon as we enter the PlacingShips state we execute this snipped that evaluates if all ships have been placed.</aside>
            </section>
            <section>
                <h2>However, This won't work</h2>
                <blockquote class="fragment">def onTransition(transitionHandler: TransitionHandler): Unit<hr>Set handler which is called upon each state transition, i.e. not when staying in the same state.</blockquote>
                <aside class="notes">onTransition only works when transitioning from a State A to a State B where A != B</aside>
            </section>
            <section>
                <h2>State Machine Revisited!</h2>
                <img src="images/battleship_revisited.svg" alt="Battleship game FSM" class="no-border"/>
                <aside class="notes">What we need to do here is add an extra state in the FSM in order to force a transition. This is somehow similar to the DB de-normalization.</aside>
            </section>
            <section>
                <h2>Let's check the code again</h2>
                <pre><code>when(PlacingShips) {
  case Event(PlacedShip, _) =>
    goto(CheckingPlacedShips)
}

when(CheckingPlacedShips) {
 case Event(PlaceShip(playerId, shipId, coord, size, vertical), data)=>
  if (data.canShipBePlaced(playerId, shipId, coord, size, vertical))
    sender ! Message("Placed")
  else sender ! Message("Wrong Position")
  goto(PlacingShips)
    using data.placeShip(playerId, shipId, coord, size, vertical)
 case Event(ShipsPlaced, _) =>
  players.foreach(_ ! Message("Ships placed"))
  goto(WaitingForNextPlayer)
}</code></pre>
                <aside class="notes">Here we can see that the old state is only meant to transition to the new state, which contains all the logic we saw before.
                Now instead of staying we transition from one state to the other.</aside>
            </section>
            <section>
                <h2>And the Transition Handlers</h2>
                <pre><code>case _ -> PlacingShips => self ! PlacedShip
case _ -> CheckingPlacedShips =>
  if (nextStateData.shipsToPlace.forall(_.isEmpty)) self ! ShipsPlaced</code></pre>
                <aside class="notes">And here we can see the automatic transition from one state to another.</aside>
            </section>
            <section>
                <h2>Let's tackle the remaining states</h2>
                <img src="images/battleship_revisited.svg" alt="Battleship game FSM" class="no-border"/>
            </section>
            <section>
                <h2>Let's tackle the remaining states</h2>
                <pre><code>when(WaitingForNextPlayer) {
  case Event(NextPlayer, data) =>
    stay using data.copy(currentPlayer = data.opponent)
  case Event(PlaceShot(playerId, x, y), data) =>
    goto(CheckingShot) using data.copy(pendingShot = Some(x, y))
}
when(CheckingShot) {
  case Event(Miss, data) =>
    goto(WaitingForNextPlayer) using data.copy(pendingShot = None)
  case Event(Hit, data) =>
    goto(HitShip) using data.shoot.copy(pendingShot = None)
}
when(HitShip) {
  case Event(ShipsAlive, data) =>
    goto(WaitingForNextPlayer) using data
  case Event(AllShipsSunk, _) =>  goto(EndGame)
}</code></pre>
                <aside class="notes">Next states follow the same way as the previous ones.</aside>
            </section>
            <section>
                <h2>With their Entry Actions</h2>
                <pre><code>case _ -> WaitingForNextPlayer =>
  players.foreach(_ ! Message(s"End of ${nextStateData.currentPlayer} turn"))
  self ! NextPlayer
case _ -> CheckingShot =>
  if (nextStateData.wouldBeAShot) {
    players.foreach(_ ! Message(s"Ship Hit at ${nextStateData.pendingShot}!"))
    self ! Hit
  }
  else {
    players.foreach(_ ! Message(s"Missed at ${nextStateData.pendingShot}!"))
    self ! Miss
  }
case _ -> HitShip =>
  if (nextStateData.areShipsAlive(nextStateData.opponent))
    self ! ShipsAlive
  else self ! AllShipsSunk
case _ -> EndGame => players.foreach(_ ! Message("Game is Over"))</code></pre>
                <aside class="notes">The same goes for the transitions associated to them.</aside>
            </section>
            <section>
                <h2>What Happens with Timers?</h2>
                <img src="images/battleship_timers_revisited.svg" alt="Battleship game FSM" class="fragment no-border"/>
                <aside class="notes">But what happens if we want to prevent users from waiting infinitely to place a shot? We need to add timers.
                The new FSM is the same as before, but now we have an extra transition triggered by a timeout.</aside>
            </section>
            <section>
                <h2>We can add State Timeouts</h2>
                <pre><code>when(WaitingForNextPlayer, stateTimeout = 30 seconds) {
  case Event(NextPlayer, data) =>
    stay using data.copy(currentPlayer = data.opponent)
  case Event(PlaceShot(playerId, x, y), data) =>
    goto(CheckingShot) using data.copy(pendingShot = Some(x, y))
  case Event(StateTimeout, data) =>
    stay using data.copy(currentPlayer = data.opponent)
}</code></pre>
                <aside class="notes">Adding a timeout is pretty easy, as we can extend the when definition with an amount of time that the machine can stay in this specific state.</aside>
            </section>
            <section>
                <h2>Now Let's Add Some Tests!</h2>
            </section>
            <section>
                <h2>Simple Test...</h2>
                <pre><code>def getBattleshipFSM() = {
  val player1Probe = TestProbe()
  val player2Probe = TestProbe()
  TestFSMRef(new BattleShipActor(player1Probe.ref, player2Probe.ref))
}
"A Battleship actor" should {
  "start in WaitingForPlayers state and be initialized" in {
    val battleshipFSM = getBattleshipFSM()
    assert(battleshipFSM.stateName === WaitingForPlayers)
    val stateData = battleshipFSM.stateData
    assert(stateData.currentPlayer === 1)
    assert(stateData.grids.forall(_.isEmpty))
    assert(stateData.pendingShot === None)
  }
}</code></pre>
            </section>
            <section>
                <h2>Now Checking Transitions...</h2>
                <pre><code>"A Battleship actor" when {
  "in WaitingForPlayer state" can {
    "go to CheckingPlacedShips state" in {
      val battleshipFSM = getBattleshipFSM()
      assert(battleshipFSM.stateName === WaitingForPlayers)
      battleshipFSM ! PlaceShip(playerId = 1, id = 2,
        Coord(x = 1, y = 1), size = 3, vertical = true)
      assert(battleshipFSM.stateName === CheckingPlacedShips)
      assert(battleshipFSM.stateData.isOccupied(playerIdx = 1,
        Coord(x = 1, y = 1)))
    }
  }
}</code></pre>
            </section>
            <section>
                <h2>And Checking Intermediate States</h2>
                <pre><code>"A Battleship actor" when {
  "in CheckingPlacedShips state" can {
    "go to WaitingForNextPlayer" in {
      val battleshipFSM = getBattleshipFSM()
      battleshipFSM.setState(CheckingPlacedShips, battleshipFSM.stateData)
      assert(battleshipFSM.stateName === CheckingPlacedShips)
      battleshipFSM ! ShipsPlaced
      assert(battleshipFSM.stateName === WaitingForNextPlayer)
      assert(battleshipFSM.isStateTimerActive)
    }
  }
}</code></pre>
            </section>
            <section>
                <h2>Cool...</h2><h2 class="fragment">but what if I have more than 2 users?</h2>
            </section>
            <section>
                <h2>Scaling Up</h2>
                <img class="no-border" src="images/ScaleUpBattleshipOrchestration.svg" alt="Scale Up"/>
                <aside class="notes">This solution tries to utilize as many resources as the machine where it runs can offer. This solution is good, up to some poin.
                Because getting bigger machines it gets more expensive in a exponential fashion.</aside>
            </section>
            <section>
                <h2>Scaling Out</h2>
                <img class="no-border" src="images/ScaleOutBattleshipOrchestration.svg" alt="Scale Up"/>
                <aside class="notes">So what to do when the machine is not big enough to hold our current load? Easy, we just move to another machine.
                Actors can be created in the same machine or in a remote machine, and messages are sent to them in the same way.
                In this example for example, when we can't grow anymore in the same machine, we can expand to another one.</aside>
            </section>
        </section>
        <section>
            <section>
                <h1>Wrap Up</h1>
                <ul>
                    <li>Nice DSL for building FSM</li>
                    <li>Forget locks!</li>
                    <li>Focused on state-centric FSM</li>
                    <li>You might need to adapt your FSM to Akka</li>
                    <li>Extensive use of Mocks for testing</li>
                </ul>
                <aside class="notes">There both good points and bad points when developing FSM with Akka. The toolkit provides a nice DSL and thanks to the actor model you can scale easily without needing to care about locks.
                However, you might need to adapt your FSM and you need to use a lot of mocks.</aside>
            </section>
            <section>
                <h1>And remember...</h1>
                <h2 class="fragment">JVM Developers can also build Games!</h2>
            </section>
        </section>
        <section>
            <h1>Q & A</h1>
        </section>
        <section>
            <h1>Further Information</h1>
            <div><a href="http://inside.gameduell.com/">inside.gameduell.com</a></div>
            <div><a href="http://www.techtalk-berlin.de/">www.techtalk-berlin.de</a></div>
        </section>
        <section>
            <h1>Link to Slides</h1>
            <a href="https://jlprat.github.io/Building-Games-with-Akka-FSM/goto.html">jlprat.github.io/Building-Games-with-Akka-FSM/goto.html</a>
            <p>Code will appear in GitHub repo soon...</p>
            <footer>
                <p class="author">
                    GOTO nights | 2015/10/07 | Josep Prat | <a href="http://twitter.com/jlprat">@jlprat</a>
                </p>
            </footer>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

</body>
</html>
